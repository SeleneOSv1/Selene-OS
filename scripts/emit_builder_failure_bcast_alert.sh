#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="${SELENE_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"
cd "${ROOT_DIR}" >/dev/null 2>&1 || true

ALERT_KIND="${ALERT_KIND:-PRODUCTION_SOAK_CHECK_FAILED}"
ALERT_AT_UTC="${ALERT_AT_UTC:-$(date -u +"%Y-%m-%dT%H:%M:%SZ")}"
ALERT_SUMMARY="${ALERT_SUMMARY:-Selene production soak check failed.}"
ALERT_DETAIL="${ALERT_DETAIL:-}"
WATCHDOG_CMD="${WATCHDOG_CMD:-scripts/check_builder_production_soak_watchdog.sh}"
PROPOSAL_ID="${PROPOSAL_ID:-unknown}"
RELEASE_STATE_ID="${RELEASE_STATE_ID:-unknown}"

# Legacy/default recipient fallback when routing file is not initialized.
BCAST_TENANT_ID="${BCAST_TENANT_ID:-tenant_builder}"
BCAST_SENDER_USER_ID="${BCAST_SENDER_USER_ID:-selene_builder}"
BCAST_RECIPIENT_USER_ID="${BCAST_RECIPIENT_USER_ID:-owner}"
BCAST_RECIPIENT_DISPLAY="${BCAST_RECIPIENT_DISPLAY:-JD}"
BCAST_URGENCY="${BCAST_URGENCY:-URGENT}" # URGENT | NON_URGENT
BCAST_ALERT_COOLDOWN_MINUTES="${BCAST_ALERT_COOLDOWN_MINUTES:-60}"
BCAST_NOTIFY_DESKTOP="${BCAST_NOTIFY_DESKTOP:-1}" # 1 -> osascript notification

BCAST_LOG_FILE="${BCAST_LOG_FILE:-.dev/builder_failure_bcast_ledger.log}"
BCAST_APP_INBOX_FILE="${BCAST_APP_INBOX_FILE:-.dev/selene_app_inbox.log}"
BCAST_ROUTING_FILE="${BCAST_ROUTING_FILE:-.dev/builder_failure_alert_routing.env}"
BCAST_ACK_FILE="${BCAST_ACK_FILE:-.dev/builder_failure_alert_ack.log}"
BCAST_ROUTING_AUDIT_FILE="${BCAST_ROUTING_AUDIT_FILE:-.dev/builder_failure_alert_routing_audit.log}"

fail() {
  echo "BCAST_ALERT_FAIL:$1" >&2
  exit 1
}

if [[ "${BCAST_URGENCY}" != "URGENT" && "${BCAST_URGENCY}" != "NON_URGENT" ]]; then
  fail "invalid_BCAST_URGENCY expected=URGENT_or_NON_URGENT actual=${BCAST_URGENCY}"
fi
if [[ "${BCAST_NOTIFY_DESKTOP}" != "0" && "${BCAST_NOTIFY_DESKTOP}" != "1" ]]; then
  fail "invalid_BCAST_NOTIFY_DESKTOP expected=0_or_1 actual=${BCAST_NOTIFY_DESKTOP}"
fi
if ! [[ "${BCAST_ALERT_COOLDOWN_MINUTES}" =~ ^[0-9]+$ ]]; then
  fail "invalid_BCAST_ALERT_COOLDOWN_MINUTES expected_non_negative_integer actual=${BCAST_ALERT_COOLDOWN_MINUTES}"
fi

mkdir -p "$(dirname "${BCAST_LOG_FILE}")"
mkdir -p "$(dirname "${BCAST_APP_INBOX_FILE}")"
mkdir -p "$(dirname "${BCAST_ROUTING_FILE}")"
mkdir -p "$(dirname "${BCAST_ACK_FILE}")"
mkdir -p "$(dirname "${BCAST_ROUTING_AUDIT_FILE}")"
touch "${BCAST_ACK_FILE}"

sanitize_single_line() {
  local value="$1"
  value="$(printf "%s" "${value}" | tr '\n' ' ' | tr '\r' ' ' | tr '|' '/')"
  printf "%s" "${value}" | sed 's/[[:space:]]\+/ /g; s/^ //; s/ $//'
}

hash16() {
  local value="$1"
  if command -v shasum >/dev/null 2>&1; then
    printf "%s" "${value}" | shasum -a 256 | awk '{print substr($1,1,16)}'
    return 0
  fi
  printf "%s" "${value}" | cksum | awk '{printf "%016x", $1}'
}

default_routing_vars() {
  ALERT_PRIMARY_USER_ID="${ALERT_PRIMARY_USER_ID:-${BCAST_RECIPIENT_USER_ID}}"
  ALERT_PRIMARY_DISPLAY="${ALERT_PRIMARY_DISPLAY:-${BCAST_RECIPIENT_DISPLAY}}"
  ALERT_FALLBACK_USER_ID="${ALERT_FALLBACK_USER_ID:-}"
  ALERT_FALLBACK_DISPLAY="${ALERT_FALLBACK_DISPLAY:-}"
  ALERT_DELEGATED_USER_ID="${ALERT_DELEGATED_USER_ID:-}"
  ALERT_DELEGATED_DISPLAY="${ALERT_DELEGATED_DISPLAY:-}"
  ALERT_DELEGATION_ACTIVE="${ALERT_DELEGATION_ACTIVE:-0}" # 0 | 1
  ALERT_RESPONSE_TIMEOUT_MINUTES="${ALERT_RESPONSE_TIMEOUT_MINUTES:-5}"
  ALERT_LAST_PENDING_BCAST_ID="${ALERT_LAST_PENDING_BCAST_ID:-}"
  ALERT_LAST_PENDING_RECIPIENT_USER_ID="${ALERT_LAST_PENDING_RECIPIENT_USER_ID:-}"
  ALERT_LAST_PENDING_SENT_EPOCH="${ALERT_LAST_PENDING_SENT_EPOCH:-0}"
  ALERT_LAST_PENDING_ACK_EPOCH="${ALERT_LAST_PENDING_ACK_EPOCH:-0}"
  ALERT_LAST_PENDING_ACK_STATUS="${ALERT_LAST_PENDING_ACK_STATUS:-NONE}" # NONE|PENDING|ACKED|IGNORED
  ALERT_LAST_ROUTE_SOURCE="${ALERT_LAST_ROUTE_SOURCE:-PRIMARY}"
}

write_routing_file() {
  local tmp
  tmp="$(mktemp "${TMPDIR:-/tmp}/builder_failure_alert_routing.$$.XXXXXXXXXXXX.env")"
  {
    printf "# Auto-generated by emit_builder_failure_bcast_alert.sh\n"
    printf "ALERT_PRIMARY_USER_ID=%q\n" "${ALERT_PRIMARY_USER_ID}"
    printf "ALERT_PRIMARY_DISPLAY=%q\n" "${ALERT_PRIMARY_DISPLAY}"
    printf "ALERT_FALLBACK_USER_ID=%q\n" "${ALERT_FALLBACK_USER_ID}"
    printf "ALERT_FALLBACK_DISPLAY=%q\n" "${ALERT_FALLBACK_DISPLAY}"
    printf "ALERT_DELEGATED_USER_ID=%q\n" "${ALERT_DELEGATED_USER_ID}"
    printf "ALERT_DELEGATED_DISPLAY=%q\n" "${ALERT_DELEGATED_DISPLAY}"
    printf "ALERT_DELEGATION_ACTIVE=%q\n" "${ALERT_DELEGATION_ACTIVE}"
    printf "ALERT_RESPONSE_TIMEOUT_MINUTES=%q\n" "${ALERT_RESPONSE_TIMEOUT_MINUTES}"
    printf "ALERT_LAST_PENDING_BCAST_ID=%q\n" "${ALERT_LAST_PENDING_BCAST_ID}"
    printf "ALERT_LAST_PENDING_RECIPIENT_USER_ID=%q\n" "${ALERT_LAST_PENDING_RECIPIENT_USER_ID}"
    printf "ALERT_LAST_PENDING_SENT_EPOCH=%q\n" "${ALERT_LAST_PENDING_SENT_EPOCH}"
    printf "ALERT_LAST_PENDING_ACK_EPOCH=%q\n" "${ALERT_LAST_PENDING_ACK_EPOCH}"
    printf "ALERT_LAST_PENDING_ACK_STATUS=%q\n" "${ALERT_LAST_PENDING_ACK_STATUS}"
    printf "ALERT_LAST_ROUTE_SOURCE=%q\n" "${ALERT_LAST_ROUTE_SOURCE}"
  } > "${tmp}"
  mv -f "${tmp}" "${BCAST_ROUTING_FILE}"
}

load_routing_file() {
  default_routing_vars
  if [[ -f "${BCAST_ROUTING_FILE}" ]]; then
    # shellcheck disable=SC1090
    source "${BCAST_ROUTING_FILE}"
  fi
  default_routing_vars

  if [[ -z "${ALERT_PRIMARY_USER_ID}" ]]; then
    ALERT_PRIMARY_USER_ID="${BCAST_RECIPIENT_USER_ID}"
  fi
  if [[ -z "${ALERT_PRIMARY_DISPLAY}" ]]; then
    ALERT_PRIMARY_DISPLAY="${BCAST_RECIPIENT_DISPLAY}"
  fi
  if [[ "${ALERT_DELEGATION_ACTIVE}" != "0" && "${ALERT_DELEGATION_ACTIVE}" != "1" ]]; then
    ALERT_DELEGATION_ACTIVE="0"
  fi
  if ! [[ "${ALERT_RESPONSE_TIMEOUT_MINUTES}" =~ ^[0-9]+$ ]]; then
    ALERT_RESPONSE_TIMEOUT_MINUTES="5"
  fi
  if ! [[ "${ALERT_LAST_PENDING_SENT_EPOCH}" =~ ^[0-9]+$ ]]; then
    ALERT_LAST_PENDING_SENT_EPOCH="0"
  fi
  if ! [[ "${ALERT_LAST_PENDING_ACK_EPOCH}" =~ ^[0-9]+$ ]]; then
    ALERT_LAST_PENDING_ACK_EPOCH="0"
  fi
  case "${ALERT_LAST_PENDING_ACK_STATUS}" in
    NONE|PENDING|ACKED|IGNORED) ;;
    *) ALERT_LAST_PENDING_ACK_STATUS="NONE" ;;
  esac
}

audit_routing_event() {
  local line="$1"
  printf "%s\n" "${line}" >> "${BCAST_ROUTING_AUDIT_FILE}"
}

latest_ack_epoch_for_bcast() {
  local bcast_id="$1"
  awk -F'|' -v wanted="bcast_id=${bcast_id}" '
    /^ACK\|/ {
      has_id = 0;
      ack_epoch = "";
      for (i = 1; i <= NF; i++) {
        if ($i == wanted) has_id = 1;
        if ($i ~ /^epoch=/) {
          split($i, kv, "=");
          ack_epoch = kv[2];
        }
      }
      if (has_id && ack_epoch != "") latest = ack_epoch;
    }
    END { if (latest != "") print latest; }
  ' "${BCAST_ACK_FILE}" 2>/dev/null || true
}

select_recipient_route() {
  local now_epoch="$1"

  ROUTE_SOURCE="PRIMARY"
  ROUTE_RECIPIENT_USER_ID="${ALERT_PRIMARY_USER_ID}"
  ROUTE_RECIPIENT_DISPLAY="${ALERT_PRIMARY_DISPLAY}"

  local fallback_user_id="${ALERT_PRIMARY_USER_ID}"
  local fallback_display="${ALERT_PRIMARY_DISPLAY}"
  if [[ -n "${ALERT_FALLBACK_USER_ID}" ]]; then
    fallback_user_id="${ALERT_FALLBACK_USER_ID}"
  fi
  if [[ -n "${ALERT_FALLBACK_DISPLAY}" ]]; then
    fallback_display="${ALERT_FALLBACK_DISPLAY}"
  fi

  if [[ "${ALERT_DELEGATION_ACTIVE}" == "1" && -n "${ALERT_DELEGATED_USER_ID}" ]]; then
    ROUTE_SOURCE="DELEGATED"
    ROUTE_RECIPIENT_USER_ID="${ALERT_DELEGATED_USER_ID}"
    ROUTE_RECIPIENT_DISPLAY="${ALERT_DELEGATED_DISPLAY:-${ALERT_DELEGATED_USER_ID}}"

    if [[ -n "${ALERT_LAST_PENDING_BCAST_ID}" && "${ALERT_LAST_PENDING_RECIPIENT_USER_ID}" == "${ALERT_DELEGATED_USER_ID}" && "${ALERT_LAST_PENDING_SENT_EPOCH}" -gt 0 ]]; then
      local ack_epoch
      ack_epoch="$(latest_ack_epoch_for_bcast "${ALERT_LAST_PENDING_BCAST_ID}")"
      if [[ -n "${ack_epoch}" && "${ack_epoch}" -ge "${ALERT_LAST_PENDING_SENT_EPOCH}" ]]; then
        ALERT_LAST_PENDING_ACK_EPOCH="${ack_epoch}"
        ALERT_LAST_PENDING_ACK_STATUS="ACKED"
        ALERT_LAST_ROUTE_SOURCE="DELEGATED"
        write_routing_file
        audit_routing_event "ROUTING_AUDIT|epoch=${now_epoch}|event=delegate_ack_received|bcast_id=${ALERT_LAST_PENDING_BCAST_ID}|recipient_user_id=${ALERT_DELEGATED_USER_ID}|ack_epoch=${ack_epoch}"
      else
        local timeout_seconds="$(( ALERT_RESPONSE_TIMEOUT_MINUTES * 60 ))"
        local age_seconds="$(( now_epoch - ALERT_LAST_PENDING_SENT_EPOCH ))"
        if [[ "${age_seconds}" -ge "${timeout_seconds}" ]]; then
          ALERT_DELEGATION_ACTIVE="0"
          ALERT_LAST_PENDING_ACK_EPOCH="${now_epoch}"
          ALERT_LAST_PENDING_ACK_STATUS="IGNORED"
          ALERT_LAST_ROUTE_SOURCE="FALLBACK_AFTER_IGNORED_DELEGATE"
          write_routing_file
          audit_routing_event "ROUTING_AUDIT|epoch=${now_epoch}|event=delegate_ignored_timeout|delegated_user_id=${ALERT_DELEGATED_USER_ID}|fallback_user_id=${fallback_user_id}|age_seconds=${age_seconds}|timeout_seconds=${timeout_seconds}|last_bcast_id=${ALERT_LAST_PENDING_BCAST_ID}"

          ROUTE_SOURCE="FALLBACK_AFTER_IGNORED_DELEGATE"
          ROUTE_RECIPIENT_USER_ID="${fallback_user_id}"
          ROUTE_RECIPIENT_DISPLAY="${fallback_display}"
        fi
      fi
    fi
  fi
}

load_routing_file

alert_key_raw="$(sanitize_single_line "${ALERT_KIND}|${ALERT_SUMMARY}|${PROPOSAL_ID}|${RELEASE_STATE_ID}|${WATCHDOG_CMD}")"
alert_key="$(hash16 "${alert_key_raw}")"
bcast_id="bcast_builder_fail_${alert_key}"
decision_ref="decision_builder_fail_${alert_key}"
epoch_now="$(date +%s)"

select_recipient_route "${epoch_now}"
BCAST_RECIPIENT_USER_ID="${ROUTE_RECIPIENT_USER_ID}"
BCAST_RECIPIENT_DISPLAY="${ROUTE_RECIPIENT_DISPLAY}"
ROUTE_SOURCE="${ROUTE_SOURCE}"

last_epoch="$(awk -F'|' -v key="alert_key=${alert_key}" '
  $0 ~ key {
    for (i = 1; i <= NF; i++) {
      if ($i ~ /^epoch=/) {
        split($i, kv, "=");
        if (kv[2] != "") {
          last = kv[2];
        }
      }
    }
  }
  END { if (last != "") print last; }
' "${BCAST_LOG_FILE}" 2>/dev/null || true)"

if [[ -n "${last_epoch}" ]]; then
  cooldown_seconds="$(( BCAST_ALERT_COOLDOWN_MINUTES * 60 ))"
  age_seconds="$(( epoch_now - last_epoch ))"
  if [[ "${age_seconds}" -lt "${cooldown_seconds}" ]]; then
    printf "%s\n" "BCAST_ALERT_SKIP cooldown_active=1 alert_key=${alert_key} age_seconds=${age_seconds} cooldown_seconds=${cooldown_seconds} bcast_id=${bcast_id} route_source=${ROUTE_SOURCE} recipient_user_id=${BCAST_RECIPIENT_USER_ID}"
    exit 0
  fi
fi

detail_line="$(sanitize_single_line "${ALERT_DETAIL}")"
summary_line="$(sanitize_single_line "${ALERT_SUMMARY}")"
state_after_deliver="WAITING"
if [[ "${BCAST_URGENCY}" == "URGENT" ]]; then
  state_after_deliver="FOLLOWUP"
fi

printf "%s\n" \
  "BCAST_ALERT_EVENT|epoch=${epoch_now}|at=${ALERT_AT_UTC}|alert_key=${alert_key}|tenant_id=${BCAST_TENANT_ID}|sender_user_id=${BCAST_SENDER_USER_ID}|recipient_user_id=${BCAST_RECIPIENT_USER_ID}|recipient_display=${BCAST_RECIPIENT_DISPLAY}|simulation_id=BCAST_CREATE_DRAFT|simulation_type=DRAFT|recipient_state=SENT|urgency=${BCAST_URGENCY}|route_source=${ROUTE_SOURCE}|bcast_id=${bcast_id}|decision_ref=${decision_ref}|alert_kind=${ALERT_KIND}|proposal_id=${PROPOSAL_ID}|release_state_id=${RELEASE_STATE_ID}" \
  >> "${BCAST_LOG_FILE}"

printf "%s\n" \
  "BCAST_ALERT_EVENT|epoch=${epoch_now}|at=${ALERT_AT_UTC}|alert_key=${alert_key}|tenant_id=${BCAST_TENANT_ID}|sender_user_id=${BCAST_SENDER_USER_ID}|recipient_user_id=${BCAST_RECIPIENT_USER_ID}|recipient_display=${BCAST_RECIPIENT_DISPLAY}|simulation_id=BCAST_DELIVER_COMMIT|simulation_type=COMMIT|delivery_method=SELENE_APP|recipient_state=${state_after_deliver}|urgency=${BCAST_URGENCY}|route_source=${ROUTE_SOURCE}|bcast_id=${bcast_id}|decision_ref=${decision_ref}|alert_kind=${ALERT_KIND}|summary=${summary_line}|detail=${detail_line}" \
  >> "${BCAST_LOG_FILE}"

printf "%s\n" \
  "SELENE_APP_THREAD|epoch=${epoch_now}|at=${ALERT_AT_UTC}|thread_ref=builder_failure_alerts|recipient=${BCAST_RECIPIENT_DISPLAY}|recipient_user_id=${BCAST_RECIPIENT_USER_ID}|bcast_id=${bcast_id}|state=${state_after_deliver}|urgency=${BCAST_URGENCY}|route_source=${ROUTE_SOURCE}|summary=${summary_line}|detail=${detail_line}" \
  >> "${BCAST_APP_INBOX_FILE}"

ALERT_LAST_PENDING_BCAST_ID="${bcast_id}"
ALERT_LAST_PENDING_RECIPIENT_USER_ID="${BCAST_RECIPIENT_USER_ID}"
ALERT_LAST_PENDING_SENT_EPOCH="${epoch_now}"
ALERT_LAST_PENDING_ACK_EPOCH="0"
ALERT_LAST_PENDING_ACK_STATUS="PENDING"
ALERT_LAST_ROUTE_SOURCE="${ROUTE_SOURCE}"
write_routing_file
audit_routing_event "ROUTING_AUDIT|epoch=${epoch_now}|event=alert_sent|route_source=${ROUTE_SOURCE}|recipient_user_id=${BCAST_RECIPIENT_USER_ID}|recipient_display=${BCAST_RECIPIENT_DISPLAY}|bcast_id=${bcast_id}|alert_kind=${ALERT_KIND}"

notify_result="skipped"
if [[ "${BCAST_NOTIFY_DESKTOP}" == "1" && -x /usr/bin/osascript ]]; then
  notify_title="Selene Failure Alert"
  notify_subtitle="${ALERT_KIND}"
  notify_body="$(sanitize_single_line "Issue: ${summary_line} Fix: Fail-closed stop + BCAST alert dispatched. Should I proceed after review?")"
  notify_sound="Ping"
  if [[ "${BCAST_URGENCY}" == "URGENT" ]]; then
    notify_sound="Funk"
  fi

  # Escape backslashes and double quotes for AppleScript string literals.
  notify_title="${notify_title//\\/\\\\}"
  notify_title="${notify_title//\"/\\\"}"
  notify_subtitle="${notify_subtitle//\\/\\\\}"
  notify_subtitle="${notify_subtitle//\"/\\\"}"
  notify_body="${notify_body//\\/\\\\}"
  notify_body="${notify_body//\"/\\\"}"

  if /usr/bin/osascript \
    -e "display notification \"${notify_body}\" with title \"${notify_title}\" subtitle \"${notify_subtitle}\" sound name \"${notify_sound}\"" \
    >/dev/null 2>&1; then
    notify_result="desktop_sent"
  else
    notify_result="desktop_failed"
  fi
fi

printf "%s\n" \
  "BCAST_ALERT_EVENT|epoch=${epoch_now}|at=${ALERT_AT_UTC}|alert_key=${alert_key}|bcast_id=${bcast_id}|decision_ref=${decision_ref}|notify_result=${notify_result}|route_source=${ROUTE_SOURCE}" \
  >> "${BCAST_LOG_FILE}"

echo "BCAST_ALERT_OK bcast_id=${bcast_id} decision_ref=${decision_ref} recipient_user_id=${BCAST_RECIPIENT_USER_ID} recipient_display=${BCAST_RECIPIENT_DISPLAY} recipient_state=${state_after_deliver} route_source=${ROUTE_SOURCE} notify_result=${notify_result} alert_kind=${ALERT_KIND}"
